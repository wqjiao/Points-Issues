# 正则表达式

## 简介

## 正则表达式方法

* `reg.exec(str)`
    一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回null）。
    ```js
    /^(.*)\.(.+)$/.exec('hello.png'); // ['hello.png', 'hello', 'png']
    ```

* `reg.test(str)`
    一个在字符串中测试是否匹配的RegExp方法，它返回true或false。
    ```js
    /^(.*)\.(.+)$/.test('hello.png'); // true
    ```

* `str.match(reg)`
    一个在字符串中执行查找匹配的String方法，它返回一个数组或者在未匹配到时返回null。
    ```js
    'hello.png'.match(/^(.*)\.(.+)$/); // ['hello.png', 'hello', 'png']
    ```

* `str.search(reg)`
    一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。
    ```js
    'hello.png'.search(/^(.*)\.(.+)$/); // 0
    ```

* `str.replace(reg, str1)`
    一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。
    ```js
    'hello.pn-g'.replace(/[^a-z.]/g, ''); // hello.png
    ```

* `str.split([separator[, limit]])`
    一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的String方法。
    ```js
    'hello.png'.split(/^(.*)\.(.+)$/); // ["", "hello", "png", ""]
    ```

## 正则表达式语法

### 普通字符

包括 所有数字、大小写字母、下划线、所有标点符号及其他符号等。

    0 ~ 9
    a ~ z A ~ Z
    _、，。\,./
    ...

### 非打印字符

表示非打印字符的转义序列

* \cx

    匹配由x指明的控制字符。，例如：

        \cM 匹配一个 Control-M 或回车符。
        x 的值必须为 A-Z 或 a-z 之一。
        否则，将 c 视为一个原义的 'c' 字符。

* \f

    匹配一个换页符。等价于 \x0c 和 \cL。

* \n

    匹配一个换行符。等价于 \x0a 和 \cJ。

* \r

    匹配一个回车符。等价于 \x0d 和 \cM。

* \s

    匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。

* \S

    匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。

* \t

    匹配一个制表符。等价于 \x09 和 \cI。

* \v

    匹配一个垂直制表符。等价于 \x0b 和 \cK。

### 特殊字符

一些有特殊含义的字符，如上面说的 runoo*b 中的 *，在其前面加一个\,对其进行转义，正则表达式（runoo\*b）即匹配字符串中的特殊字符。

* $

    匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\n' 或 '\r'。要匹配 $ 字符本身，请使用 \$。
( )	标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \( 和 \)。

* *

    匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 \*。

* +

    匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \+。

* .

    匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 \. 。

* [
    
    标记一个中括号表达式的开始。要匹配 [，请使用 \[。

* ?

    匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。

* \

    将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， 'n' 匹配字符 'n'。'\n' 匹配换行符。序列 '\\' 匹配 "\"，而 '\(' 则匹配 "("。

* ^

    匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 \^。

* {
    
    标记限定符表达式的开始。要匹配 {，请使用 \{。

* |

    指明两项之间的一个选择。要匹配 |，请使用 \|。

### 限定符

限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种

* *

    匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。

* +

    匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。

* ?

    匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 、 "does" 中的 "does" 、 "doxy" 中的 "do" 。? 等价于 {0,1}。

* {n}

    n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。

* {n,}

    n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。

* {n,m}

    m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。

### 定位符

定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。

定位符用来描述字符串或单词的边界，^ 和 $ 分别指字符串的开始与结束，\b 描述单词的前或后边界，\B 表示非单词边界。

正则表达式的定位符有：

* ^

    匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。

* $

    匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。

* \b

    匹配一个单词边界，即字与空格间的位置。

* \B

    非单词边界匹配。

### 元字符


## 运算符优先级

正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。

相同优先级的从左到右进行运算，不同优先级的运算先高后低。下表从最高到最低说明了各种正则表达式运算符的优先级顺序：

* \ 转义符

* (), (?:), (?=), [] 圆括号和方括号

* *, +, ?, {n}, {n,}, {n,m}	限定符

* ^, $, \任何元字符、任何字符	定位点和序列（即：位置和顺序）

* |	替换，"或"操作

    字符具有高于替换运算符的优先级，使得"m|food"匹配"m"或"food"。若要匹配"mood"或"food"，请使用括号创建子表达式，从而产生"(m|f)ood"。

## 常用正则表达式

* [a-z] 匹配所有的小写字母 
* [A-Z] 匹配所有的大写字母 
* [a-zA-Z] 匹配所有的字母 
* [0-9] 匹配所有的数字 
* [0-9\.\-] 匹配所有的数字，句号和减号 
* [ \f\r\t\n] 匹配所有的白字符

* ^[a-zA-Z0-9_]+$ 所有包含一个以上的字母、数字或下划线的字符串 
* ^[1-9][0-9]*$ 所有的正整数 
* ^\-?[0-9]+$ 所有的整数 
* ^[-]?[0-9]+(\.[0-9]+)?$ 所有的浮点数

## 在线测试正则表达式

* [在线工具](http://tool.oschina.net/regex/)
* [正则表达式手册](http://tool.oschina.net/uploads/apidocs/jquery/regexp.html)

## 20 个常用正则表达式

在掘金上看到一篇关于正则表达式的文章，下面是 [技匠](https://www.jianshu.com/p/e7bb97218946) 总结的 20个正则表达式。
* 1 . 校验密码强度
密码的强度必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间。
    ^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$

* 2. 校验中文
字符串仅能是中文。
    ^[\\u4e00-\\u9fa5]{0,}$

* 3. 由数字、26个英文字母或下划线组成的字符串
    ^\\w+$

* 4. 校验E-Mail 地址
同密码一样，下面是E-mail地址合规性的正则检查语句。
[\\w!#$%&'*+/=?^_`{|}~-]+(?:\\.[\\w!#$%&'*+/=?^_`{|}~-]+)*@(?:[\\w](?:[\\w-]*[\\w])?\\.)+[\\w](?:[\\w-]*[\\w])?

* 5. 校验身份证号码
下面是身份证号码的正则校验。15 或 18位。
15位：
^[1-9]\\d{7}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}$

18位：
^[1-9]\\d{5}[1-9]\\d{3}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}([0-9]|X)$

* 6. 校验日期
“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。
^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$

* 7. 校验金额
金额校验，精确到2位小数。
^[0-9]+(.[0-9]{2})?$

* 8. 校验手机号
下面是国内 13、15、18开头的手机号正则表达式。（可根据目前国内收集号扩展前两位开头号码）
^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$

* 9. 判断IE的版本
IE目前还没被完全取代，很多页面还是需要做版本兼容，下面是IE版本检查的表达式。
^.*MSIE [5-8](?:\\.[0-9]+)?(?!.*Trident\\/[5-9]\\.0).*$

* 10. 校验IP-v4地址
IP4 正则语句。
\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b

* 11. 校验IP-v6地址
IP6 正则语句。
(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))

* 12. 检查URL的前缀
应用开发中很多时候需要区分请求是HTTPS还是HTTP，通过下面的表达式可以取出一个url的前缀然后再逻辑判断。
if (!s.match(/^[a-zA-Z]+:\\/\\//))
{
    s = 'http://' + s;
}

* 13. 提取URL链接
下面的这个表达式可以筛选出一段文本中的URL。
^(f|ht){1}(tp|tps):\\/\\/([\\w-]+\\.)+[\\w-]+(\\/[\\w- ./?%&=]*)?

* 14. 文件路径及扩展名校验
验证windows下文件路径和扩展名（下面的例子中为.txt文件）
^([a-zA-Z]\\:|\\\\)\\\\([^\\\\]+\\\\)*[^\\/:*?"<>|]+\\.txt(l)?$

* 15. 提取Color Hex  Codes
有时需要抽取网页中的颜色代码，可以使用下面的表达式。
^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$

* 16. 提取网页图片
假若你想提取网页中所有图片信息，可以利用下面的表达式。
\\< *[img][^\\\\>]*[src] *= *[\\"\\']{0,1}([^\\"\\'\\ >]*)

* 17. 提取页面超链接
提取html中的超链接。
(<a\\s*(?!.*\\brel=)[^>]*)(href="https?:\\/\\/)((?!(?:(?:www\\.)?'.implode('|(?:www\\.)?', $follow_list).'))[^"]+)"((?!.*\\brel=)[^>]*)(?:[^>]*)>

* 18. 查找CSS属性
通过下面的表达式，可以搜索到相匹配的CSS属性。
^\\s*[a-zA-Z\\-]+\\s*[:]{1}\\s[a-zA-Z0-9\\s.#]+[;]{1}

* 19. 抽取注释
如果你需要移除HMTL中的注释，可以使用如下的表达式。
<!--(.*?)-->

* 20. 匹配HTML标签
通过下面的表达式可以匹配出HTML中的标签属性。
<\\/?\\w+((\\s+\\w+(\\s*=\\s*(?:".*?"|'.*?'|[\\^'">\\s]+))?)+\\s*|\\s*)\\/?>

* 正则表达式在线测试工具 [regex101](https://regex101.com/#javascript)

* 正则表达式快速学习 [指南](https://docs.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-language-quick-reference)
