
* 1.可编辑表格(EditableTable)：编辑 -> 保存/取消

    `rowKey` 不能使用固定值，除 动态生成的key (new Date()),否则出现输入 input 数据时自动失去焦点
    
* 2.同一个 `Form` 标签中包裹的HTML，不能存在多个 type 为 'submit' 的按钮，哪怕用的不是同一个 `Form.create()`,但是触发的

```js
<Form onSubmit={this.handleSubmit}>
    <Modal>
        <Form onSubmit={this.handleSearch}>
            <Button htmlType="submit">查询</Button>
        </Form>
    </Modal>
    <Button htmlType="submit">提交</Button>
</Form>
```

* 3.如果子组件中存在 `componentDidMount` 生命周期执行了获取接口的情况，避免在含有 `loading` 的 antd 元素的父组件上添加 loading，否则组件不断卸载/渲染，接口不断获取

* 4.router 中带入 query 值类型的准确性

```js
router.push({
    pathname: `/demo`,
    query: {
        isModify: true,
    },
});

// 到页面中获取值
const isModify = this.props.location.query.isModify; // true || 'true'
// 注意：路由跳转进来时，isModify 为 Boolean 类型 true，而刷新当前页面时，isModify 为字符串 'true'
```

原因？？？(可能刷新页面时直接获取了地址栏信息做解析)

* 5.`CheckboxGroup` 中 `value` 值，通过接口获取值发生改变，页面中展示的选中项不变，实际打印出来的值是变了的。添加了一个随机 key 即可解决问题。

```js
 handleLoanPeriodChange = data => {
    const {
        dispatch,
        financialStepTwo: {productFields = {}},
    } = this.props;
    const {pageFields = []} = productFields;

    pageFields.map(item => {
        item.map(arr => {
            if (arr.name === 'loanPeriod') {
                data.list.map(val => {
                    if (!arr.initialValue.includes(val.periods)) {
                        arr.initialValue.push(val.periods);
                    }
                });
                this.handleLoanList(arr.initialValue);
            }
        });
    });
    dispatch({
        type: 'financialStepTwo/update',
        payload: productFields,
    });
};

<CheckboxGroup
    style={{width: '100%'}}
    value={loanProiodValue} // ['9'] => ['9', '12']
    onChange={e => this.handleChange(e, data.name)}
    // key={Math.random()}
>
    <Row>
        {data.list.length > 0 &&
            data.list.map(val => {
                return (
                    <Checkbox
                        value={val.value}
                        disabled={val.disabled}
                        key={`${data.name}-${val.value}`}
                    >
                        {val.label}
                    </Checkbox>
                );
            })}
    </Row>
</CheckboxGroup>
```

原因： redux 单项数据流，数据拷贝时采用了引用类型，引用了同一个内存地址。强行使用 `setState` 或者 `key={Math.random()}` 或者 深拷贝 `JSON.parse(JSON.stringfy)`;

* 6.React-防止内存泄漏处理
`Can't perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method`

组件在销毁后设置了state，防止出现内存泄漏的情况发出的警告。

* 7.`Upload` 组件上传问题
已经上传的文件列表（受控），使用此参数时，如果遇到 onChange 只调用一次的问题 `uploading`，[参考](https://github.com/ant-design/ant-design/issues/2423)

